## 数据库（关系型vs非关系型）相关理论
>1，存储引擎基于表
>2，数据库有哪些功能特性，如果让我来实现，应该怎么实现
>3，联合索引的最左匹配原则

## 分析mysql源码
* [mysql 5.7分区表性能下降性能分析](https://juejin.im/entry/59ba22156fb9a00a59593f25)
* [mysql源码](https://github.com/mysql/mysql-server)

## innoDB深入研究
* [innodb深入学习和研究](https://github.com/BoobooWei/inside-innodb)

## java Mybatis-plus学习
* [Mybatis-plus学习](https://mp.baomidou.com/guide/dts.html)

### ACID
>1，Atomicity原子性：一个事务中所有操作都必须全部完成，要么全部不完成。     
>2，Consistency一致性. 在事务开始或结束时，数据库应该在一致状态。   
>3，Isolation隔离层. 事务将假定只有它自己在操作数据库，彼此不知晓。   
>4，Durability持久性. 一旦事务完成，就不能返回   

### BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性：
>1，Basically Available基本可用。支持分区失败(e.g. sharding碎片划分数据库)    
>2，Soft state软状态 状态可以有一段时间不同步，异步。   
>3，Eventually consistent最终一致，最终数据是一致的就可以了，而不是时时高一致     



## profiling分析查询

>1，查看是否开启profiling：select @@profiling;
>2，开profiling。注意测试完关闭该特性，否则耗费资源：set profiling=1;
>3，查看所有记录profile的SQL：show profiles;
>4，查看指定ID的SQL的详情：show profile for query 1;
>5，测试完，关闭该特性：set profiling=0;
>6，执行一条语句之后，查看执行效率：show profiles;
>7，查看mysql最大链接数： show variables like 'max_connections';
>8，查看已经使用的最大连接数：show status like 'max%connections';max_used_connections / max_connections * 100% （理想值≈ 85%）
>9，同时查看不同资源开销 **show profile block io,cpu for query $Query_ID**

## 查看数据文件：show global variables like "%datadir%";
>1,.frm文件：存储数据表的框架结构，文件名与表名相同，每个表对应一个同名frm文件，与操作系统和存储引擎无关，即不管MySQL运行在何种操作系统上，使用何种存储引擎，都有这个文件
>2,InnoDB采用表空间（tablespace）来管理数据，存储表数据和索引:1)ibdata1、ibdata2等：系统表空间文件，存储InnoDB系统信息和用户数据库表数据和索引，所有表共用;  2).ibd文件：单表表空间文件，每个表使用一个表空间文件（file per table），存放用户数据库表数据和索引;   3)日志文件： ib_logfile1、ib_logfile2
>3,MyISAM数据库表文件:1).MYD文件：即MY Data，表数据文件;  2).MYI文件：即MY Index，索引文件

## 查看慢查询日志：show variables like "%slow%";
>1，慢查询日志用来记录响应时间超过阈值的SQL语句，set global slow_query_log='ON';只是对当前数据库有效，如果MySQL数据库重启后就会失效。所以如果要永久生效，就要修改配置文件 my.cnf
>2，我们可以设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询日志文件中。该阈值可以通过参数 long_query_time 来设置，默认为10秒，set global long_query_time=0.05;
>3，查询是否用到索引show variables like 'log_queries_not_using_indexes';
>4，错误日志文件，慢查询日志文件那样用cat，head, tail等命令可以查看
>5，mysqldumpslow iz2zeaf3cg1099kiidi06mz-slow.log

## 二进制日志：记录了对数据库执行更改的所有操作，但是不包括select和show这类操作：mysqlbinlog mysqld-bin.000001
>1，恢复(recovery)： 某些数据的恢复需要二进制日志，如当一个数据库全备文件恢复后，我们可以通过二进制的日志进行 point-in-time的恢复
>2，复制(replication) : 通过复制和执行二进制日志使得一台远程的 MySQL 数据库(一般是slave 或者 standby) 与一台MySQL数据库(一般为master或者primary) 进行实时同步
>3，审计(audit)：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击


## 查询日志:记录select和show操作：show variables like "general_log%";
>1，开启： set global general_log='ON';

## pt-query-digest 是分析MySQL查询日志最有力的工具
>1，可以分析binlog，Generallog，slowlog，也可以通过show processlist或者通过 tcpdump 抓取的MySQL协议数据来进行分析，比 mysqldumpslow 更具体，更完善
>2，pt-query-digest  slow.log > slow_report.log

## mysql体系结构
![mysql体系结构](./mysql_frameword_struct.png "mysql体系结构")

>1，四种隔离级别，默认Repeatable
>2，insert buffer
>3，二次写 double write
>4，自适应哈希索引，adaptive hash index
>5，预读，read ahead

## 引擎
>1，InnoDB
>2，MyISAM
>3，Memory：数据存放在内存
>4，NDB：集群引擎
>5，Archive：只支持select和insert
>6，Federated
>7，Maria

![各种引擎比较](./multi-engines-compare.png "各种引擎比较")

## InnoDB深入分析

* [深入分析InnoDB](https://github.com/BoobooWei/inside-innodb/blob/master/lock.md)
  
>1，聚集方式，表的存储按照逐渐的顺序进行存放，没有主键，则默认生成一个6B的ROWID
>2，MVCC，多版本并发控制，获得高并发

## MyISAM
>1，不支持事务，表锁设计，支持全文索引，主要面向OLAP
>2，只缓存索引文件，不缓冲数据文件

## B-Tree
**模拟查找关键字 29 的过程：**

>1，根据根节点找到磁盘块 1，读入内存。【磁盘 I/O 操作第 1 次】
>2，比较关键字 29 在区间（17,35），找到磁盘块 1 的指针 P2。
>3，根据 P2 指针找到磁盘块 3，读入内存。【磁盘 I/O 操作第 2 次】
>4，比较关键字 29 在区间（26,30），找到磁盘块 3 的指针 P2。
>5，根据 P2 指针找到磁盘块 8，读入内存。【磁盘 I/O 操作第 3 次】
>6，在磁盘块 8 中的关键字列表中找到关键字 29。

![磁盘&B-Tree](./B-Tree.png "磁盘&B-Tree")

## B+Tree

>1，数据是存在叶子节点中的；
>2，数据节点之间是有指针指向的。
>3，**MyISAM和MySQL是采用的B+Tree**。目前大多数数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构
>4，系统从 **磁盘读取数据到内存时是以磁盘块（block）为基本单位**的，**InnoDB存储引擎使用页**作为数据读取单位，页是其磁盘管理的最小单位，默认page大小是 16k。系统的一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。
>5，在查询数据时如果一个页中的每条数据都能助于定位数据记录的位置，这将会减少磁盘 I/O 的次数，提高查询效率

![磁盘&B+Tree](./B+Tree.png "磁盘&B+Tree")

### InnoDB的多线程模型
>1，master thread
>2，IO thread：AIO(async IO)
>3，Purge thread
>4，Page Cleaner thread

## checkpoint机制：缓冲池-》磁盘


## InnoDB内存数据对象
>1，LRU(Latest recent used，最近最少使用，最频繁的再LRU列表前端))
>2，midpoint insertion strategy：新访问的页，不直接放到LRU列表的前端，都是放到midpoint（默认是5/8，show variables like ‘innodb_old_blocks_pct’;显示百分比） ,midpoit之前称为new列表，之后为old列表。可能新访问的不是热点数据，直接插入LRU列表前端，可能会把列表尾的热点数据刷出缓冲池

![InnoDB内存数据对象](./InnoDB-mem-data-obj.png "InnoDB内存数据对象")


## 查询

![查询路径](./select-path.png "查询路径")

## 分区：水平分区，并不支持垂直分区
>1，主键肯定是唯一键，那么分区键就必须是主键的真子集。然而目前大部分数据表都不会把有实质意义的业务字段作为主键，这就使得分区的业务意义大大降低了。比如，主键是自增长的id，可以视作记录插入的时间顺序，如果按照id分区，再以class_code之类有实际意义的字段为条件做查询时，分区就派不上用场了

### RANGE分区（常用）
```
create table employees (
    id int not null,
    fname varchar(30),
    lname varchar(30),
    hired date not null default '1970-01-01',
    separated date not null default '9999-12-31',
    job_code int not null,
    store_id int not null
) partition by range (store_id) (
    partition p0 values less than (6),
    partition p1 values less than (11),
    partition p2 values less than (16),
    partition p3 values less than (21)，
    partition p3 values less than maxvalue
);
```
### LIST分区：将要匹配的任何值都必须在值列表中找到
```
create table employees (
    id int not null,
    fname varchar(30),
    lname varchar(30),
    hired date not null default '1970-01-01',
    separated date not null default '9999-12-31',
    job_code int not null,
    store_id int not null
) partition by list(store_id)
    partition pNorth values in (3,5,6,9,17),
    partition pEast values in (1,2,10,11,19,20),
    partition pWest values in (4,12,13,14,18),
    partition pCentral values in (7,8,15,16)
)；
```
### HASH分区：PARTITION BY HASH (expr)，“expr”是一个返回一个整数的表达式
```
create table employees (
    id int not null,
    fname varchar(30),
    lname varchar(30),
    hired date not null default '1970-01-01',
    separated date not null default '9999-12-31',
    job_code int not null,
    store_id int not null
) partition by hash(store_id)  partitions 4；
```

### KSY分区：KEY分区只支持计算一列或多列。必须有一列或多列包含整数值
```
 create table tk (
    col1 int not null,
    col2 char(5),
    col3 date
) partition by linear key (col1)
partitions 3;
```
### 复合分区

### 优化分区
>1，ALTER TABLE emp optimize partition p1,p2;

### 合并分区
>1，alter table te reorganize partition p1,p3 into (partition p1 values less than (1000));

### 查看分区信息
>1，SELECT * FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'part_tab'
>2，explain partitions select * from `part_tab`;
>3，SELECT PARTITION_NAME,TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'sale_data';
>4，**如果是range分区表，那么null行将被保存在范围最小的分区。如果是list分区表，那么null行将被保存到list为0的分区。在按HASH和KEY分区的情况下，任何产生NULL值的表达式mysql都视同它的返回值为0。为了避免这种情况的产生，建议分区键设置成NOT NULL**


### QA
>1，分区删除或调整分区规则了，会怎么样
>2，分区数据不均

### locks表：用于记录InnoDB事务尝试申请但还未获取的锁，以及阻塞其他事务的事务所拥有的锁 
>1,select * from information_schema.innodb_locks;